# 시스템 설계 기초: 규모 확장성과 처리율 제한

---

## 📌 목차

1. **사용자 수에 따른 규모 확장성**
   - 시스템 확장 전략
   - 주요 확장 컴포넌트

2. **처리율 제한 장치 설계**
   - 필요성과 배치
   - 알고리즘 비교
   - 구현 고려사항

---

## 1장. 사용자 수에 따른 규모 확장성

### 시스템 확장의 필요성

소수의 사용자부터 시작하여 **수백만 사용자를 지원하는 시스템**으로 확장하기 위해 필요한 핵심 설계 원칙을 다룹니다.

---

### 시스템 확장 단계별 진화

#### 단계 1: 단일 서버 (Single Server)
```
[Client] → [Web Server + DB + Cache]
```
- **구성**: 모든 구성 요소가 하나의 서버에서 실행
- **장점**: 단순하고 관리가 쉬움
- **단점**: 확장성 제한, 단일 장애점(Single Point of Failure)

---

#### 단계 2: 수직적 확장 (Vertical Scaling)

**고성능 자원(CPU, RAM)을 서버에 추가**

| 항목 | 설명 |
|:---|:---|
| **방식** | 서버의 하드웨어 성능 향상 |
| **장점** | 단순한 구현, 애플리케이션 변경 최소화 |
| **단점** | 하드웨어 한계, 비용 증가, 장애 시 복구 어려움 |

---

#### 단계 3: 수평적 확장 (Horizontal Scaling)

**서버를 추가하여 성능 개선**

| 항목 | 설명 |
|:---|:---|
| **방식** | 서버 인스턴스 추가 |
| **장점** | 무한 확장 가능, 장애 대응 용이, 비용 효율적 |
| **단점** | 로드 밸런싱 필요, 상태 관리 복잡 |

> 💡 **대규모 애플리케이션에는 수평적 확장이 더 적합합니다**

---

### 데이터베이스 선택: RDBMS vs NoSQL

| 구분 | RDBMS | NoSQL |
|:---|:---|:---|
| **사용 시기** | 초기 단계, 복잡한 쿼리 필요 | 대규모 데이터, 낮은 지연 시간 |
| **특징** | ACID 보장, 복잡한 관계 표현 | 높은 확장성, 유연한 스키마 |
| **NoSQL 고려 사항** | • 아주 낮은 응답 지연(latency) 요구<br>• 비정형 데이터 처리<br>• 아주 많은 양의 데이터 저장 |

---

## 주요 확장 컴포넌트

### 1. 로드 밸런서 (Load Balancer)

**역할**: 웹 서버 그룹에 트래픽 부하를 고르게 분산

```
[Client] → [Load Balancer] → [Web Server 1]
                              [Web Server 2]
                              [Web Server N]
```

- 사용자는 로드 밸런서의 공개 IP로 접속
- 웹 서버는 클라이언트 접속을 직접 처리하지 않음
- 장애가 발생한 서버를 자동으로 제외 (Health Check)

---

### 2. 데이터베이스 다중화 (DB Redundancy)

```
[Write] → [Primary DB] → [Replication] → [Secondary DB 1]
                                           [Secondary DB 2]
```

#### 주요 기능
- **성능 향상**: 
  - 쓰기 연산 → 주 서버(Primary)
  - 읽기 연산 → 부 서버들(Secondaries)로 분산
- **안정성**: 재해 복구, 데이터 보존
- **고가용성**: 주 서버 장애 시 부 서버로 자동 전환 (Failover)

---

### 3. 캐시 (Cache)

**목적**: 자주 접근하는 데이터를 메모리에 저장하여 성능 향상

#### 캐시 전략
- **캐시 메모리 크기**: 
  - 액세스 패턴에 따라 **충분히 할당(overprovision)**
  - 데이터가 자주 밀려나지 않도록 적절한 크기 설정

- **데이터 방출 정책 (Eviction Policy)**:
  - **LRU** (Least Recently Used): 가장 오랫동안 사용되지 않은 데이터
  - **LFU** (Least Frequently Used): 사용 빈도가 가장 낮은 데이터
  - **FIFO** (First In First Out): 가장 먼저 들어온 데이터

---

### 4. CDN (Content Delivery Network)

**목적**: 지리적으로 분산된 서버 네트워크로 정적 콘텐츠 전송

```
[User (서울)] → [CDN Edge (서울)]
[User (뉴욕)] → [CDN Edge (뉴욕)]
```

- **캐시 대상**: 이미지, CSS, JavaScript 등 정적 콘텐츠
- **효과**: 지연 시간 감소, 서버 부하 분산
- **대표 서비스**: CloudFront, CloudFlare, Akamai

---

### 5. 메시지 큐 (Message Queue)

**목적**: 서비스 간 결합도 감소 (느슨한 결합, Loosely Coupled)

```
[Producer] → [Message Queue] → [Consumer]
```

- **비동기 처리**: 작업 처리 시간이 긴 프로세스를 비동기로 처리
- **규모 확장성**: 작업자(Worker)를 추가하여 처리 능력 향상
- **안정성**: 메시지 손실 방지, 재시도 메커니즘
- **대표 기술**: RabbitMQ, Apache Kafka, AWS SQS

---

### 6. 데이터베이스 샤딩 (Sharding)

**목적**: 대규모 데이터베이스를 작은 단위(샤드)로 분할

```
[Shard 1] User ID: 1-1000
[Shard 2] User ID: 1001-2000
[Shard 3] User ID: 2001-3000
```

#### 핵심 개념
- **샤딩 키 (Sharding Key)**: 데이터 분산 기준 (예: 사용자 ID, 지역)

#### 주요 어려움
1. **리샤딩 (Resharding)**: 데이터 재분산 시 복잡도 증가
2. **핫스팟 키 (Hotspot Key)**: 특정 키에 요청 집중 (예: 유명인사 데이터)
3. **조인 및 비정규화**: 여러 샤드에 걸친 조인 연산 어려움

---

## 4장. 처리율 제한 장치 설계

### 처리율 제한 장치란?

**Rate Limiter**: 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어

#### 목적
- 시스템 **자원 고갈(resource starvation)** 방지
- **DoS(Denial of Service) 공격** 방지
- 공정한 자원 사용 보장

---

### 처리율 제한 배치 위치

#### 1. 서버 측 (Server-side)
- API 서버에 직접 제한 장치 구현
- 각 서버가 독립적으로 처리율 제한

#### 2. 미들웨어 (Middleware) ⭐ 권장
- API 서버로 가는 요청을 통제하는 미들웨어
- 제한 초과 시 **HTTP 429 (Too Many Requests)** 응답
- 중앙 집중식 관리 가능

```
[Client] → [Rate Limiter Middleware] → [API Server]
```

---

## 처리율 제한 알고리즘 비교

### 알고리즘 선택 가이드

| 알고리즘 | 정확도 | 메모리 | 버스트 처리 | 구현 난이도 | 사용 사례 |
|:---|:---:|:---:|:---:|:---:|:---|
| **토큰 버킷** | 중 | 낮음 | ✅ 가능 | 쉬움 | API Gateway, 일반적인 API |
| **누출 버킷** | 중 | 낮음 | ❌ 불가 | 쉬움 | 안정적 출력 필요 시 |
| **고정 윈도우** | 낮음 | 낮음 | ❌ 불가 | 매우 쉬움 | 간단한 제한 필요 시 |
| **이동 윈도우 로그** | 높음 | 높음 | ✅ 가능 | 어려움 | 정확한 제한 필요 시 |

---

### 1. 토큰 버킷 (Token Bucket) ⭐ 가장 널리 사용

#### 동작 원리
```
[토큰 공급] → [버킷 (용량: N)] → [요청 처리]
```

- 버킷에 토큰이 주기적으로 채워짐 (Refill Rate)
- 요청 도착 시 토큰 사용
- 토큰이 없으면 요청 버려짐 (Dropped)

#### 특징
- ✅ 구현이 쉬움
- ✅ 메모리 효율적
- ✅ 짧은 시간 집중 트래픽(Burst) 처리 가능
- ❌ 버킷 크기와 공급률 튜닝 필요

**예시**: 초당 10개 토큰, 버킷 크기 100 → 최대 100개까지 버스트 가능

---

### 2. 누출 버킷 (Leaky Bucket)

#### 동작 원리
```
[요청] → [큐] → [고정 처리율로 처리]
```

- 요청은 큐에 저장
- 큐가 가득 차면 새 요청 버려짐
- 지정된 시간마다 고정된 처리율로 처리

#### 특징
- ✅ 메모리 효율적 (큐 크기 제한)
- ✅ 안정적인 출력(Stable Outflow) 보장
- ❌ 버스트 트래픽 처리 불가
- ❌ 최신 요청이 버려질 수 있음

**사용 사례**: 안정적인 처리율이 중요한 시스템

---

### 3. 고정 윈도우 카운터 (Fixed Window Counter)

#### 동작 원리
```
[00:00-00:59] 카운터: 100/100
[01:00-01:59] 카운터: 0/100 (새 윈도우)
```

- 타임라인을 고정된 간격의 윈도우로 분할
- 각 윈도우마다 카운터 관리

#### 문제점 ⚠️
**윈도우 경계 부근 트래픽 집중 시**:
- 예: 00:59에 100개 요청, 01:00에 100개 요청 → 총 200개 처리 (한도 초과!)

#### 특징
- ✅ 구현이 매우 간단
- ❌ 정확도 낮음
- ❌ 윈도우 경계 문제

---

### 4. 이동 윈도우 로그 (Sliding Window Log)

#### 동작 원리
```
현재 시간: 10:05
[10:00] 요청 1
[10:02] 요청 2
[10:04] 요청 3
[10:05] 새 요청 → 10:00 이전 타임스탬프 삭제 후 판단
```

- 모든 요청의 타임스탬프를 로그에 보관
- 새 요청 시 윈도우 크기 이전 타임스탬프 삭제
- 로그 크기로 허용 여부 판단

#### 특징
- ✅ 매우 정교한 제한 메커니즘
- ✅ 한도 초과 불가
- ❌ 다량의 메모리 사용 (거부된 요청 타임스탬프도 보관)

---

## 구현 세부 사항

### 1. 카운터 저장소

#### Redis 사용 권장 ⭐

**이유**:
- 메모리 기반 → 디스크 접근 지연 최소화
- **INCR**: 원자적 카운터 증가
- **EXPIRE**: 자동 만료 시간 설정
- 분산 환경에서 공유 가능

**예시**:
```redis
INCR user:123:requests
EXPIRE user:123:requests 60
```

---

### 2. 경쟁 조건 (Race Condition) 해결

#### 문제 상황
```
Thread 1: 읽기(5) → 증가(6) → 쓰기(6)
Thread 2: 읽기(5) → 증가(6) → 쓰기(6)
결과: 6 (실제로는 7이어야 함)
```

#### 해결 방법
- **Redis INCR**: 원자적 연산 사용
- **Lua 스크립트**: 여러 연산을 원자적으로 실행
- **분산 락**: Redis의 SETNX 사용

---

### 3. HTTP 응답 헤더

#### 클라이언트에 제공하는 정보

| 헤더 | 설명 | 예시 |
|:---|:---|:---|
| `X-RateLimit-Remaining` | 남은 요청 수 | `95` |
| `X-RateLimit-Limit` | 윈도우당 허용 요청 수 | `100` |
| `X-RateLimit-Retry-After` | 재시도까지 대기 시간(초) | `60` |

#### 응답 예시
```
HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Retry-After: 60
```

---

## 실제 사용 사례

### 대표 서비스별 처리율 제한

| 서비스 | 제한 방식 | 제한 수치 |
|:---|:---|:---|
| **GitHub API** | 토큰 버킷 | 시간당 5,000 requests (인증 사용자) |
| **Twitter API** | 이동 윈도우 | 15분당 15 requests (일부 엔드포인트) |
| **AWS API Gateway** | 토큰 버킷 | 초당 10,000 requests (기본) |
| **Stripe API** | 이동 윈도우 | 초당 100 requests (기본) |

---