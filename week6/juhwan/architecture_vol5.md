# 📘 11장. 알림 시스템 설계 (Notification System Design)

## 1️⃣ 알림 시스템의 기본 요구사항

### ✅ 기능적 요구사항

- 푸시 알림 (모바일)
- 이메일
- SMS
- 대량 전송 가능
- 실패 시 재시도 가능

### ✅ 비기능적 요구사항

- 확장성: 수백만 사용자 대상
- 신뢰성: 알림 유실 방지
- 중복 전송 방지
- 지연 허용: 실시간일 필요 없음

> **🔑 포인트:**  
> 알림은 “실시간 서비스”가 아니고, 비동기 처리에 가장 적합한 영역임

---

## 2️⃣ 알림 시스템의 기본 구조

| 잘못된 설계                          | 올바른 설계(정답 구조) |
| ------------------------------------ | ---------------------- |
| API 서버에서 직접 FCM/Email/SMS 전송 | 1. Client              |

→ 2. API Server  
→ 3. Message Queue (Kafka/SQS/RabbitMQ)  
→ 4. Notification Worker  
→ 5. 외부 알림 서비스(FCM/Email/SMS) |
| 트래픽 폭주 시 API 서버 과부하 | |
| 장애 전파 위험 | 큐를 반드시 거침으로서 트래픽 흡수, 안정성 확보 |

> **📌 실무 포인트:**  
> "알림은 반드시 메시지 큐를 거친다!"

---

## 3️⃣ 메시지 큐를 사용하는 이유 (면접 핵심)

- API 서버와 알림 전송 로직을 완전히 분리 (서버 부하 분산)
- 트래픽 스파이크 흡수 (버퍼 역할)
- 실패 시 재시도 로직 구현 가능
- 비동기로 API 응답속도 개선 및 사용자 경험 향상

> **💬 면접 답변 예시:**  
> “알림은 비동기 처리 대상이므로 메시지 큐를 사용해 안정성과 확장성을 확보합니다.”

---

## 4️⃣ 중복 알림 & 실패 처리 전략

### 🔁 중복 방지

- 알림 ID (UUID) 할당
- Idempotency Key 사용
- 전송 이력 DB 기록으로 중복 체크

### ❗ 실패 처리

- Retry Queue로 일정 횟수 재시도
- Dead Letter Queue(DLQ) 운영
- 재시도 초과 시:
  - 관리자에게 경고 알림
  - 로그 기록 후 포기(혹은 후처리)

---

## 5️⃣ 사용자 설정 (Opt-in / Opt-out)

- 알림 종류별 발송 여부 설정 관리 필요
  - 마케팅 알림 ❌ (거부 가능)
  - 서비스 알림 ⭕ (주로 필수)
- 알림 발송 전 사용자 설정값을 반드시 조회하고 필터링 필요

> **📌 실무 포인트:**  
> GDPR, 광고성 알림 등 법적 규제도 대응 필요

---

## 6️⃣ (추가) 자주 나오는 꼬리 질문

- **왜 알림은 트랜잭션에 묶지 않는가?**  
  (과도한 결합/성능저하/실패전파 방지 목적)
- **알림 순서 보장이 필요한가?**  
  (일반적으로 불필요, 필요시 큐/토픽 설계 주의)
- **푸시 실패시 fallback 전략은?**  
  (예: SMS/Email 등 다중 채널로 대체)

---

# 📘 12장. 검색 자동완성 시스템 설계 (Autocomplete / Typeahead)

## 1️⃣ 자동완성 시스템의 요구사항

### ✅ 기능적 요구사항

- 입력 중 실시간 추천
- 접두사(Prefix) 기반 검색
- 인기 검색어 반영

### ✅ 비기능적 요구사항

- 초저지연 (몇 ms ~ 수십 ms 내 응답)
- 고가용성
- 읽기 트래픽 매우 많음

---

## 2️⃣ DB 직접 조회가 안 되는 이유

### ❌ 잘못된 접근

- `SELECT * FROM keywords WHERE word LIKE 'ap%';`  
  (사용자 입력마다 쿼리 발생 → TPS 급증, 인덱스 효율 저하)

### 📌 핵심 포인트

- 자동완성은 DB 성능 문제가 아니라 "읽기 최적화"의 문제임

---

## 3️⃣ 핵심 자료구조: Trie (접두사 트리)

- **예시**
  ```
  a
   └─ p
      └─ p
         └─ l
            └─ e
  ```
- **장점**
  - Prefix 검색 시간복잡도 : O(length)
  - 매우 빠름 → 자동완성에 최적화

> **💬 면접 팁:**  
> “자동완성에는 Trie 자료구조가 가장 적합합니다.”

---

## 4️⃣ 실제 서비스 구조 (실무 구조)

1. Client
2. API Server
3. In-memory Cache (Redis)
4. Trie/Simple Sorted Set

- Redis에 자동완성 데이터를 저장(Top K)
- DB는 데이터 원본 저장소 역할만
- 실시간 요청은 Redis만 조회

> **📌 실무 포인트:**  
> “DB는 쓰기, Redis는 읽기”

---

## 5️⃣ 인기 검색어 처리 전략

- 검색 로그 수집 (클릭/입력 등)
- 배치/스트리밍 처리로 집계
- 검색 빈도 기반 랭킹 계산
- 상위 N개만 Trie/Redis에 반영 (Top K 전략)
  - 모든 검색어를 들고 있지 않음 (효율적 메모리 사용)

---

## 6️⃣ 데이터 업데이트 전략

- 실시간 반영 ❌ (비용, 부하 큼)
- 배치 업데이트 ⭕ (5분, 10분, 1시간 단위 등 적절하게 선택)
- 캐시 Warm-up 필수

> **📌 실무 선택:**  
> “조금 늦더라도 안정성과 일관성 중심으로 설계”
