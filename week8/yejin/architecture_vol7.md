# 📒 15장 - 구글 드라이브 설계



## ✅ 1단계 문제 이해 및 설계 범위 확정

1. 파일 업로드, 다운로드, 동기화, 알림( 모바일, 웹 둘다)
2. 파일 암호화
3. 10gb
4. dau 10m
4. 

### 요구 사항
<기능>
- 파일 추가
- 파일 다운로드
- 파일 동기화
- 파일 갱신 이력 조회
- 파일 공유
- 파일이 편집되거나 삭제되거나 새롭게 공유될 때 알람 표시

<비기능>
- 안정성
- 빠른 동기화 속도
- 네트워크 대역폭
- 규모 확장성
- 높은 가용성


### 개략적 규모 추정
- 가입 사용자 : 오천만, dau:천만
- 모든 사용자에게 10mb 무료
- 각 평균 하루 2개, 파일 크기 평균 500mb
- 읽기, 쓰기= 1:1
- 필요한 저장 공간 = 5천만 *10gb
- 업로드 API QPS = 1천만 사용자 * 2회 업로드 / 24시간 / 3600초 = 약 240
- 최대 QPS = QPS * 2 = 480


## ✅ 2단계 개략적 설계안 제시 및 동의 구하기 
1) 파일 업로그 ,다운로드 할 웹서버
2) 데이터베이스
3) 파일을 저장할 저장소 시스템


### api

1. 파일 업로드 api
- 단순 업로드
- 이어 올리기
    - uploadType=resumable
    - data: 업로드할 로컬 파일

2. 파일 다운로드 api
- path: 다운로드할 파일의 경로

3. 파일 갱신 히스토리
- path: 갱신 히스토리를 가져올 파일의 경로
- limit: 히스토리 길이의 최대치


### 한 대 서버의 제약 극복
- 파일 공간이 여유치 않은 경우
1. 데이터 샤딩
2. s3 : 규모 확장성, 가용성, 보안, 다중화(같은 지역 내 다중화, 여러 지역 걸쳐서 다중화)

- 로드 밸런서
- 웹서버: 로드밸런서 추가하고 나면 더 많은 웹 서버 손쉽게 추가 가능, 트래픽 폭증해도 쉽게 대응
- 메타데이터 데이터베이스: 데이터베이스를 파일 저장 서버와 분리하여 spof 회피, 다중화 및 샤딩 정책 적용해 가용성, 규모 확장성 대응
- 파일 저장소: s3를 파일 저장소로 사용하고 가용성과 데이터 무손실을 보장하기 위해 2개 이상 지역에 데이터 다중화



### 동기화 충돌
- 두 사용자가 같은 파일을 동시에 업데이트하는 경우
- 사용자 1이 먼저, 이어서 사용자 2가 하려고 하면 오류

-> 합칠지, 대체할지


### 개략적 설계안
- 사용자 단말: 클라이언트
- 블록 저장소 서버: 파일 블록을 클라우드 저장소에 업로드하는 서버
    - 파일을 여러 블록으로 나누어 저장, 각 블록은 고유한 해시값
    - 해시값은 메타데이터 데이터베이스에 저장
    - 각 블록은 독립적 객체로 취급되며, 클라우드 저장소 시스템(s3)에 보관
    - 재구성하려면 블록을 원래 순서대로 합쳐애함
- 클라우드 저장소: 파일은 블록 단위로 나누어져 클라우드 저장소에 저장
- 아카이빙 저장소: 오랫동안 사용하지 않은 비활성 데이터를 저장하기 위한 컴퓨터 시스템
- 로드밸런서: 요청을 모든 api서버에 고르게 분산하는 구실
- api 서버: 파일 업로드 외에 거의 모든 것을 담당
- 메타데이터 데이터베이스: 사용자, 파일, 블록, 버전 등의 메타데이터 정보 관리
- 메타데이터 캐시: 성능을 높이기 위해 자주 쓰이는 메타데이터는 캐시한다.
- 알림 서비스: 
    - 특정 이벤트가 발생했음을 클라이언트에게 알리는데 쓰이는 발생/구독 프로토콜 기반 시스템
    -  예시 설계안의 경우에는 클라이언트에게 파일이 추가되었거나, 편집되었거나, 삭제되었음을 알려, 파일의 최신 상태를 확인하도록 하는데 쓰인다
- 오프라인 사용자 백업 큐(offline backup queue): 클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 때는 해당 정보를 이 큐에 두어 나중에 클라이언트가 접속했을 때 동기화될 수 있도록 한다.



## ✅ 3단계 상세 설계

### 블록 저장소 서버
1. 작은 블록으로 파일 분할
2. 각 블록 압축
3. 암호화
4. 클라우드 저장소로 보냄

- 델타 동기화 전략: 수정된 부분만 동기화
- 압축


### 높은 일관성 요구사항
- 사용자에 따라 파일이 다르게 보이면 안됨
- 일관성 유지를 위한 사항
    - 캐시에 보관된 사본과 데이터베이스 원본이 일치
    - 원본에 변경이 생기면 캐시 무효
    - rds 경우는 일관성 보장이 쉽자만 nosql은 기본적으로 지원하지 않아 동기화 로직 안에 프로그램해야함

### 메티데이터 데이터베이스

- user: user 테이블에는 이름, 이메일, 프로필 사진 등 사용자에 관계된 기본적 정보들이 보관
- device: device 테이블에는 단말 정보가 보관
- namespace: namespace 테이블에는 사용자의 루트 디렉터리 정보가 보관
- file: file 테이블에는 파일의 최신정보가 보관
- file_version: 파일의 갱신 이력이 보관되는 테이블,테이블에 보관되는 레코드는 전부 읽기 전용 -> 갱신 이력이 훼손되는 것을 막기 위한 조치
- block: 파일 블록에 대한 정보를 보관하는 테이블, 특정 버전의 파일은 파일 블록을 올바른 순서로 조합하기만 하면 복원해 낼 수 있음


### 업로드 절차
- 파일 메타데이터 추가
1. 클라이언트 1이 새 파일의 메타데이터를 추가하기 위한 요청 전송
2. 새 파일의 메타데이터를 데이터베이스에 저장하고 업로드 상태를 대기 중(pending)으로 변경
3. 새 파일이 추가되었음을 알림 서비스에 통지
4. 알림 서비스는 관련된 클라이언트(클라이언트 2)에게 파일이 업로드 되고 있음을 알림

---

- 파일을 클라우드 저장소에 업로드
2.1 클라이언트 1이 파일을 블록 저장소 서버에 업로드
2.2 블록 저장소 서버는 파일을 블록 단위로 쪼갠 다음 압축하고 암호화 한 다음에 클라우드 저장소에 전송
2.3 업로드가 끝나면 클라우드 스토리지는 완료 콜백(callback)을 호출. 이 콜백 호출은 API 서버로 전송됨
2.4 메타데이터 DB에 기록된 해당 파일의 상태를 완료(uploaded)로 변경
2.5 알림 서비스에 파일 업로드가 끝났음을 통지
2.6 알림 서비스는 관련된 클라이언트(클라이언트 2)에게 파일 업로드가 끝났음을 알림


### 다운로드

- 파일 변경 발생
~~~
→ (1) 서버에 변경 이벤트 기록 (캐시/큐)
→ (2) 온라인이면 즉시 전달
→ (3) 오프라인이면 보관
→ (4) 재접속 시 전달
~~~

파일이 변경되었음을 감지 -> 우선 API 서버를 통해 메타데이터를 새로 가져옴 -> 블록들을 다운받아 파일을 재구성

- 어떤 블록이 바뀌었는지 알기 위해 메타데이터를 먼저 받는다.

1. 알림 서비스가 클라이언트 2에게 누군가 파일을 변경했음을 알림
2. 알림을 확인한 클라이언트 2는 새로운 메타데이터를 요청
3. API 서버는 메타데이터 데이터베이스에게 새 메타데이터 요청
4. API 서버에게 새 메타데이터가 반환됨
5. 클라이언트 2에게 새 메타데이터가 반환됨
6. 클라이언트 2는 새 메타데이터를 받는 즉시 블록 다운로드 요청 전송
7. 블록 저장소 서버는 클라우드 저장소에서 블록 다운로드
8. 클라우드 저장소는 블록 서버에 요청된 블록 반환
9. 블록 저장소 서버는 클라이언트에게 요청된 블록 반환. 클라이언트 2는 전송된 블록을 사용하여 파일 재구성


### 알림 서비스
- 이벤트 데이터를 클라이언트들로 보내는 서비스

- 롱 폴링(long poling): 드롭박스가 이 방식을 채택하고 있다.
- 웹 소켓(web socket): 클라이언트와 서버 사이에 지속적인 통신 채널을 제공한다. 따라서 양방향 통신이 가능하다.

-> 현재는 채팅과 달리 양방향이 필요하지 않아 롱 폴링

- 파일 변경 알림처럼 빈도가 낮고 데이터가 작은 경우에는 WebSocket보다 Long Polling이 자원 효율적인 선택

	1.	클라이언트가 알림 서버에 롱 폴링 요청 전송
	2.	서버는 파일 변경이 있을 때까지 연결 유지
	3.	파일 변경 감지 시 서버는 알림 응답 후 연결 종료
	4.	클라이언트는 메타데이터 서버에 최신 파일 정보 요청
	5.	최신 메타데이터 수신 후 필요한 블록 다운로드
	6.	다운로드 완료 또는 타임아웃 시
	7.	즉시 새로운 롱 폴링 요청을 보내 연결 복원

### 저장소 공간 절약
-  파일 버전 관리에서 저장 비용을 줄이는 전략

1. 문제 배경
- 파일의 안정성과 이력 관리를 위해서는 파일의 여러 버전을 여러 데이터센터에 보관해야 한다.  
- 그러나 모든 파일 버전을 자주 백업하면:
    - 저장 용량이 빠르게 소진되고
    - 운영 비용이 급격히 증가한다.

따라서 **안정성을 유지하면서도 저장 비용을 절감하기 위한 전략**이 필요


2. 저장 비용 절감을 위한 핵심 전략

2.1 중복 제거 (Deduplication)
중복 제거는 **파일을 블록 단위로 분할한 뒤, 중복된 블록을 하나만 저장**하는 방식

- 각 블록의 해시 값을 계산하여 동일 여부 판단
- 이미 존재하는 블록은 새로 저장하지 않고 참조만 유지

**효과**
- 동일 파일의 복사본
- 유사한 파일 버전
- 자동 저장으로 생성된 중복 데이터 제거  
→ 저장 공간을 크게 절감할 수 있음

2.2 지능적 백업 전략

#### 1) 버전 개수 한도 설정
- 파일마다 보관 가능한 최대 버전 수를 제한
- 상한에 도달하면 가장 오래된 버전 삭제


#### 2) 중요한 버전만 보관
- 편집 중인 문서는 자동 저장으로 매우 많은 버전이 생성될 수 있음
- 모든 버전을 보관하는 것은 비효율적



2.3 아카이빙 저장소 (Cold Storage) 활용
자주 사용되지 않는 데이터는 **저렴한 아카이빙 저장소로 이동**
- Amazon S3 → S3 Glacier
---

### 장애 처리

1. 로드밸런서 장애
- 로드밸런서에 장애가 발생하면 세컨더리 로드밸런서가 활성화되어 트래픽을 이어받아야 함
- 로드밸런서 간에는 주기적으로 박동 신호(Heartbeat)를 주고받으며 상태를 모니터링
- 일정 시간 동안 박동 신호에 응답하지 않으면 장애가 발생한 것으로 판단

---

2. 블록 저장소 서버 장애
- 블록 저장소 서버에 장애가 발생하면 다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어받아 처리

---

3. 클라우드 저장소 장애
- S3 버킷은 여러 지역에 다중화
- 한 지역에서 장애가 발생하면 다른 지역에서 파일을 가져올 수 있음

---

4. API 서버 장애
- API 서버는 무상태(stateless) 서버
- 로드밸런서는 장애가 발생한 API 서버로 트래픽을 전달하지 않음으로써 해당 서버를 격리
~~~
 Client
  ↓
Load Balancer
  ↓
API Server A   (정상)
API Server B   (정상)
API Server C   (정상)
~~~

---

5. 메타데이터 캐시 장애
- 메타데이터 캐시 서버는 다중화
- 한 노드에 장애가 발생하더라도 다른 노드에서 데이터를 가져올 수 있음
- 장애가 발생한 서버는 새 서버로 교체

---

6. 메타데이터 데이터베이스 장애

    6.1 주 데이터베이스 서버 장애
    - 부 데이터베이스 서버 중 하나를 주 데이터베이스 서버로 승격
    - 이후 새로운 부 데이터베이스 서버를 추가

    6.2 부 데이터베이스 서버 장애
    - 다른 부 데이터베이스 서버가 읽기 연산을 처리
    - 장애가 발생한 서버는 새 서버로 교체

---

7. 알림 서비스 장애
- 접속 중인 사용자는 각각 알림 서버와 롱 폴링 연결을 하나씩 유지
- 알림 서비스는 매우 많은 사용자 연결을 관리
- 한 서버에 장애가 발생하면 많은 사용자가 롱 폴링 연결을 다시 생성해야 한다.
- 동시에 백만 개 이상의 연결을 시작하는 것은 불가능하므로, 연결 복구에는 시간이 걸릴 수 있음

---

8. 오프라인 사용자 백업 큐 장애
- 오프라인 사용자 백업 큐 역시 다중화
- 큐에 장애가 발생하면 구독 중인 클라이언트들은 백업 큐로 구독 관계를 재설정


