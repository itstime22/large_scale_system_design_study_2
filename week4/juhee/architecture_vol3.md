# 📘 7장. 분산 시스템을 위한 유일 ID 생성기 설계

### 목표

* 분산 환경에서 **중복되지 않는 ID**를 생성하는 시스템 설계.
* 요구사항:

  * **유일성 보장**
  * **숫자 기반**
  * **64비트 정수**
  * **시간 순 정렬 가능**
  * **높은 처리량(QPS ≥ 10,000)**

---

## 1. 요구사항 정의

설계 전 면접관과 질의응답을 통해 아래 요구를 확정한다.

### 기능적 요구사항

* ID는 **절대로 중복되면 안 된다**.
* ID는 **숫자로만 구성**되어야 한다.
* ID는 **64비트 정수**로 표현 가능해야 한다.
* ID는 **시간 순서대로 정렬 가능**해야 한다.
* **초당 최소 10,000개** 이상의 ID 생성 성능 필요.

---

## 2. 네 가지 기술적 접근 방식

### 2.1 다중 마스터 복제 (Multi-master Replication)

여러 DB 서버가 auto_increment 증가폭을 다르게 가져가도록 설정하여 충돌 방지.

#### 장점

* 구현 쉬움 (DB 기능 활용)

#### 단점

* 서버 추가/삭제 시 증가폭 재조정 어려움
* 여러 데이터센터에 배치하기 어려움
* 시간순 정렬 보장 어려움

---

### 2.2 UUID

128비트로 생성되는 고유 ID.

예: `09c93e62-50b4-468d-bf8a-c07e1040bfb2`

#### 장점

* 충돌 가능성이 거의 없음
* 서버 간 동기화가 불필요
* 확장성 매우 우수

#### 단점

* **128비트 → 64비트 요구사항 불충족**
* **시간 순 정렬 불가**
* **숫자가 아닌 문자 포함**

---

### 2.3 티켓 서버 (Ticket Server)

중앙 서버가 모든 ID를 생성하여 발급하는 방식.

#### 장점

* 유일성 확실히 보장
* 숫자 기반 ID 생성 쉬움
* 구현 단순

#### 단점

* **단일 장애 지점(SPOF)**
* 여러 티켓 서버 운영 시 동기화 문제 발생

---

### 2.4 트위터 스노플레이크 (Twitter Snowflake)

ID를 **시간 + 데이터센터 + 서버 + 시퀀스**로 조합하는 방식.

➡️ 이 문제의 모든 요구사항을 충족하기 때문에 최종 선택.

---

## 3. Snowflake 상세 설계

Snowflake는 64비트를 다음과 같이 분할한다:

```
| 1비트 | 41비트      | 5비트         | 5비트     | 12비트      |
| sign  | timestamp   | datacenter ID | server ID | sequence    |
```

### 3.1 Sign (1bit)

* 항상 0 (양수 표현)

### 3.2 Timestamp (41bit)

* 기준 시각(epoch) 이후 경과한 **밀리초(ms)**
* ID가 **시간 순으로 정렬**될 수 있게 함
* 41비트 → 약 **69년** 사용 가능

### 3.3 Datacenter ID (5bit)

* 최대 32개 데이터센터 구분 가능

### 3.4 Server ID (5bit)

* 각 데이터센터 내 최대 32개 서버 구분

### 3.5 Sequence (12bit)

* 같은 밀리초에 생성되는 ID들의 증가 값
* 0~4095 (4,096개)
* 밀리초가 바뀌면 0으로 초기화

---

## 4. Snowflake 운영 시 고려사항

### 4.1 시계 동기화 문제 (Clock Skew)

* 서버 간 시간이 다르면 ID 충돌 발생 가능
* NTP(Network Time Protocol)로 시간 정렬 필요
* 시간이 뒤로 움직이면 대기(wait) 처리 등 별도 로직 필요

### 4.2 비트 최적화

서비스 특성에 따라 비트 구성을 조정할 수 있음.
예:

* 동시성 낮음 → 시퀀스 비트를 줄이고 timestamp 비트 증가 가능
* 데이터센터가 많음 → datacenter ID 비트 확대

### 4.3 고가용성(HA)

* ID 생성기가 다운되면 서비스 전체가 멈출 수 있음 → 필수적으로 고가용성 구현 필요.

---

## 5. 결론

Snowflake 방식은 다음 조건을 모두 충족함:

| 요구사항     | 충족 여부 | 근거                   |
| -------- | ----- | -------------------- |
| 유일성      | ✔     | 데이터센터 + 서버 + 시퀀스 조합  |
| 숫자 기반    | ✔     | 64비트 정수              |
| 64비트     | ✔     | 비트 구조 자체가 64bit      |
| 시간 정렬 가능 | ✔     | 타임스탬프가 가장 큰 비중       |
| 고성능      | ✔     | 서버당 밀리초당 4096개 생성 가능 |

따라서 Snowflake는 **대규모 분산 시스템에 가장 적합한 ID 생성 방식**이다.

---

# 📘 **8장: URL 단축기 설계**

TinyURL, Bit.ly 같은 **URL 단축기(URL Shortener)** 를 설계하는 문제를 다룬다.
이 장에서는 문제 이해 → 개략적 설계 → 상세 설계 → 확장 고려 사항까지 완성된 URL 단축 서비스 아키텍처를 정리한다.

---

## **1단계: 문제 이해 및 요구사항 정의**

### 요구 기능

1. **URL 단축 (Shorten URL)**

   * 긴 URL을 입력받아 짧은 URL 생성
   * 단축 URL은 가능한 한 짧고 읽기 쉬워야 함
2. **URL 리디렉션 (Redirect)**

   * 단축 URL로 요청이 오면 원래 URL로 즉시 이동 (301 또는 302)
3. **높은 가용성과 확장성**
4. **삭제/갱신 기능 없음** (문제 단순화를 위해)

---

### 비기능 요구사항

* **쓰기는 초당 약 1,160건**
* **읽기는 쓰기의 10배 ≈ 초당 11,600건**
* **10년간 저장해야 하는 URL 수 ≈ 3650억 개**
* URL 평균 길이 100바이트 가정 → 약 **36.5TB 저장 공간 필요**

---

## **2단계: 개략적 설계안 제시**

### API 엔드포인트

#### ➤ 단축 URL 생성 (Shorten)

```
POST /api/v1/data/shorten
Body: { "longUrl": "https://..." }
Response: "https://tinyurl.com/abc123"
```

#### ➤ URL 리디렉션 (Redirect)

```
GET /api/v1/shortUrl/{shortUrl}
Response: 301/302 Location: <original URL>
```

### URL 리디렉션 흐름 (중요)

1. 브라우저가 단축 URL 요청
2. 서버는 **캐시에서 shortURL → longURL 조회**
3. 캐시에 없으면 DB에서 조회
4. 조회한 longURL을 캐시에 저장
5. 브라우저에게 301 또는 302 리다이렉션 반환

---

## **3단계: 상세 설계**

---

### ① 데이터 모델

`(shortURL, longURL)` 쌍을 DB에 저장하는 기본 테이블:

| id (PK) | shortURL | longURL |
| ------- | -------- | ------- |

* `id`는 고유 ID 생성기에서 생성 (Snowflake, auto-increment 등)
* `shortURL`는 Base62로 변환된 문자열

---

### ② 단축 URL 생성 방식 비교

#### A. 해시 후 충돌 해결 방식

* CRC32, MD5, SHA-1 사용
* 앞 7~8자를 잘라 사용 → 충돌 발생 가능
* 충돌 시 URL에 salt 추가 후 재해시
* 보안성 있음
* DB 체크 필요, 느림

#### B. Base-62 변환 방식 (추천)

* 숫자 ID → Base62 문자로 변환 (0-9, a-z, A-Z = 62개)
* **충돌 없음**
* 매우 빠르고 단순
* 단축 URL은 ID 증가에 따라 길이가 증가(가변 길이)

→ 실제 서비스 대부분 Base62 방식 사용

---

### ③ Base-62 변환 예시

10진수 `11157` 을 Base62로 변환:

1. 11157 ÷ 62 = 몫 179, 나머지 59 → ‘X’
2. 179 ÷ 62 = 몫 2, 나머지 55 → ‘T’
3. 2 ÷ 62 = 몫 0, 나머지 2  → ‘2’

역순으로 조합 → **2TX**

---

### ④ ID → 단축 URL 전체 흐름 (그림 8-7)

1. 긴 URL 입력
2. DB에서 longURL이 존재하는지 검색
3. 이미 있으면 기존 단축URL 반환
4. 없으면 새 ID 생성
5. ID를 Base62로 변환 → shortURL
6. (ID, shortURL, longURL)를 DB에 저장
7. shortURL을 응답

---

### ⑤ 리디렉션 상세 설계 (그림 8-8)

읽기 요청이 훨씬 많기 때문에 **캐싱 필수**:

1. 사용자가 단축 URL 요청
2. 로드밸런서가 웹 서버로 전달
3. 캐시에 shortURL이 있으면 바로 원래 URL 반환
4. 없으면 DB에서 조회
5. DB 결과를 캐시에 저장
6. 301/302로 원래 URL 반환

---

## **4단계: 확장 고려 사항 (면접 심화 질문)**

URL 단축기 설계를 더 확장할 때 고려해야 할 요소들:

---

### Rate Limiter (요청 제한)

* 악성 트래픽/봇/폭주 요청 방지
* IP 단위 RATE 제한
* Token Bucket / Sliding Window 사용

---

### 웹 서버 확장 (Stateless Architecture)

* 서버는 무상태(state-less)
* Auto Scaling으로 자유롭게 증설/축소

---

### 데이터베이스 확장

* Sharding
* Replication
* NoSQL 기반 Key-Value Store 활용

---

### 데이터 분석(Analytics)

* 어떤 링크가 얼마나, 언제, 누가 클릭했는가
* 클릭 위치/트렌드 분석
* 비즈니스 인사이트 제공

---

### 고가용성(HA), 안정성, 일관성

* 분산 시스템의 기본 속성
* 장애 복구 / Failover / Multi-Region 고려

---

## **마무리**

8장은 다음을 설계할 수 있도록 도와준다:

* 단축 URL 생성
* 리디렉션 처리
* Base62 단축 알고리즘
* 캐시/DB/로드밸런서 구조
* 대규모 트래픽 처리 구조

URL 단축기는 간단해 보이지만
대규모 서비스에서는 **다양한 기술 조합이 필요한 대표적 문제**이다.

---
