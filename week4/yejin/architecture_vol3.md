# 📒 7장 - 분산 시스템을 위한 유일 ID 생성기 설계

분산 시스템에서 유일한 id 생성기를 어떻게 설계할 것인가.

## ✅ 1단계: 문제 이해 및 설계 범위 확정

~~~
ID는 유일해야 한다. (unique)
ID는 숫자로만 구성되어있어야 한다.
ID는 발급 날짜에 따라 정렬 가능해야한다.
ID는 64비트로 표현될 수 있는 값이어야한다.
ID는 발급 날짜에 따라 정렬 가능해야 한다.
초당 10,000개의 ID를 만들 수 있어야 한다.
~~~

## ✅ 2단계 - 개략적 설계안 제시 및 동의 구하기

~~~
다중 마스터 복제 (multi-master replication)
UUID(Universally Unique Identifier)
티켓 서버(ticket server)
트위터 스노플레이크 접근법
~~~

### 다중 마스터 복제 (multi-master replication)

- auto_increment 기능을 활용
- k = 서버의 수
- 다음 키 = 이전 키 + k
- ✏️장점

    -  데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘어난다,
- ✏️ 한계
    - 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
    - ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
    - 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.

### UUID(Universally Unique Identifier)

- UUID: 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 짜리 수
- 각 웹서버는 별도의 id 생성기 사용하여 독립적인 id 생성
 
- ✏️장점

    -  생성이 단순, 서버 사이의 조율이 필요없어 동기화 이슈 없음
    - 규모 확장 쉬움
- ✏️ 한계
    - 길다
    - 시간순 정렬 불가능
    - 숫자가 아닌 값


### 티켓 서버(ticket server)

- 티켓서버: auto_increment 기능을 갖춘 데이터베이스 서버, 중앙집중형으로 하나만 사용

- ✏️장점
    -  숫자로만 구성된 ID를 쉽게 생성, 구현하기 쉬움
    
- ✏️ 한계
    - 단일장애지점

### 트위터 스노플레이크 접근법(o)

- 각개격파전략(divide and conque): 생성해야하는 id의 구조를 여러 section으로 분할

 ![alt text](https://daeakin.github.io//images/large-system/snowflake.png)
~~~
- sign bit: 1비트, 음수와 양수를 구별하는데 사용
- timestamp: 41비트, 기원 시각(epoch) 이후로 몇 밀리초가 경과했는지를 나타내는 값
- 데이터센터 ID: 5비트, 2^5 =32개의 데이터센터를 지원
- 서버 ID: 5비트, 데이터 센터 당 32개의 서버를 사용할 수 있음
- 일련번호(sequence): 12비트, 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1만큼 증가, 이 값은 1밀리초가 경과할 때마다 0으로 초기화
~~~

 

## ✅ 3단게 상세 설계

### 데이터 센터 ID와 서버 ID
사전에 시스템이 시작되기 전에 결정, 운영중 바뀌지 않음

### 타임스탬프, 일련번호
ID 생성기가 돌아가는 중에 만들어짐

### 타임스탬프
![alt text](https://velog.velcdn.com/images/kyy00n/post/511ee322-d83b-4fd7-b605-6e0280820876/image.png)
- 41비트
- 시간 순서대로 정렬 가능

### 일련번호

- 12비트 이므로 4096개의 값을 가질 수 있음
- 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보타 큰 값을 갖게 됨

## ✅ 4단계 마무리
### 시계 동기화(clock synchronization)
- Snowflake 방식은 시간 기반 ID를 사용하기 때문에
서버마다 시간이 다르면 문제가 발생함
- NTP로 해결

### 각 섹션의 길이 최적화
- 동시성이 낮고 수명이 긴 애플리케이션:  일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적

### 고가용성(high availability)
- ID 생성기는 필수 불가결(mission critical) 컴포넌트 이므로 아주 높은 가용성을 제공해야 할 것



# 📒 8장 - URL 단축기 설계

## ✅ 1단계 - 문제 이해 및 설계 범위 확정
~~~
URL 단축
URL redirection
0-9,A-Z
높은 가용성과 규모 확장성, 그리고 장애 감내가 요구 됨
단축 URL에는 숫자와 영문자를 사용할 수 있음
단축된 URL은 삭제나 갱신을 할 수 없움
~~~

## ✅ 2단계 - 개략적 설계안 제시 및 동의 구하기 

### API 엔드포인트
- URL 단축용 엔드포인트
    - 새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 실어서 POST 요청을 보내야 함


- URL 리디렉션용 엔드포인트
    -  원래 URL로 보내주기 위한 용도
 
 
### URL 리디렉션
- 원래 url로 변경 후 301 응답의 Location 헤더에 넣어 반환


| 구분 | 301 Permanent Redirect | 302 Found Redirect |
|------|----------------------|------------------|
| 의미 | 영구적인 URL 변경 | 일시적인 URL 변경 |
| 캐싱 여부 |  브라우저가 캐시함 | ❌   |
| 서버 재요청 여부 | ❌   |  매번 단축 URL 서버를 거침 |
| 서버 부하 | 감소 | 증가 |
| 트래킹(분석) 가능 여부 | 어려움 | 정확하게 가능 |
 
---
- 서버 부하를 줄이는 것이 중요: 301 Permanent moved 사용
- 트래픽 분석이 중요 (클릭 발생률, 발생위치 추적): 302 Found
-> 서버 로그에 찍히므로

### URL 단축

~~~
www.tinyurl.com/[해시값]
~~~
- 어떻게 해시값을 결정하는가
- 해시함수 조건
    1. 입력으로 주어지는 긴 URL이 다른 값이면 해시 값도 달라야한다.
    2. 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야한다.  

 
## ✅ 3단계 - 상세 설계

### 데이터 모델
-  모든걸 해시 테이블( 메모리 비용 ) ->  <단축URL, 원래 URL>의 순서쌍을 관계형 데이터베이스에 저장삭 

 
### 해시 함수
- 원래 URL을 단축 URL로 변환

### 해시 값 길이

[0-9] → 10개
[a-z] → 26개
[A-Z] → 26개
->
총 62개 문자
- 3650억 개: 단축해서 저장해야 할 URL 총 개수
 - hashValue의 길이: n이라고 할때: n을 정하기 위해서는 62 
n≥3650 억인 n의 최솟값을 찾아야 함
- n=7 이면 3.5조개의 URL을 만들 수 있음

### 1) 해시 후 충돌 해소
 
- 7글자만 사용하면   -> 서로 다른 URL이 같은 hashValue를 갖는 **충돌 발생 가능성이 증가**

- 해결법: 충돌이 해소될 때까지 **특정 문자열을 뒤에 덧붙여 재생성**

- 예시 과정:

    1. 기본 해시값: `abc1234`
    2. 이미 존재하는 값이면 충돌 발생
    3. 사전 정의된 추가 문자열 붙여 재시도
    - `abc1234 + "0"` → 충돌?
    - `abc1234 + "1"` → 충돌 해소될 때까지 반복
-  충돌 감지 법
    - db조회 -> 오버헤드 큼
    - 데이터베이스 대신 블룸 필터를 사용해서 성능을 높일 수 있음
 

W+N>N: 강한 일관성이 보장

일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹칠 것이기 때문이다.

~~~
- R=1, W=N : 빠른 읽기 연산에 최적화된 시스템
- W=1, R=N : 빠른 쓰기 연산에 최적화된 시스템
- W+R>N : 강한 일관성 보장
- W+R<=N : 강한 일관성의 보장이 없다.
~~~
요구되는 일관성 수준에 따라 조정하면 된다.

### 2) base-62 변환
- 단축 URL 구현 시, 긴 숫자를 짧은 문자열로 표현하기 위해  
**진법 변환(Base Conversion)** 방식을 사용하는 것이 일반적

    - Base62 = 한 자리에 표현 가능한 문자가 총 62개

    - 숫자: `0-9` → 10개
    - 소문자: `a-z` → 26개
    - 대문자: `A-Z` → 26개

    총 10 + 26 + 26 = **62개 문자**

    따라서 Base62 한 자리는 다음을 의미한다:

    | 10진수 | Base62 문자 |
    |-------|-------------|
    | 0 ~ 9 | `0 ~ 9` |
    | 10 ~ 35 | `a ~ z` |
    | 36 ~ 61 | `A ~ Z` |
- 사용 이유

    | 이유 | 설명 |
    |------|-----|
    | 문자 1개당 정보량 ↑ | 62가지 표현 가능 → 매우 효율적 |
    | URL에 안전한 문자 구성 | 특수문자 없음 → 인코딩 필요 X |
    | 더 짧은 URL을 제공 | 예: 10진수 8자리 숫자 → Base62 숫자 5자리 가능 |

- ex) 11157 = 2 × 62² + 55 × 62¹ + 59 × 62⁰
= [2, 55, 59] = =[2,T,X]=2TX


> 즉, 숫자를 Base62 문자로 치환해 **짧고 충돌 없는 단축 URL key**를 만든다.


### 해시 후 충돌 해소 vs base62
| 구분 | 해시 후 충돌 해소 전략 | Base62 변환 |
|------|--------------------|-------------|
| 단축 URL 길이 | 고정 길이(예: 7글자) | 가변 길이 (ID 커지면 길이 증가) |
| 유일성 보장 | 해시 충돌 발생 가능 → 충돌 해소 필요 | ID 자체가 유일해야 함(중복 불가) |
| 충돌 처리 | 문자열 덧붙이는 등의 처리 필요 | 원칙적으로 충돌 없음 (ID가 유일하면) |
| 역추적(보안) | 원본 URL 추측 불가능 | ID 증가 패턴 추정 시 다음 URL 추측 가능 |
| ID 생성 의존성 | 해시 기반, URL 입력만으로 생성 가능 | DB의 PK(숫자 ID) 존재 필요 |
    

## ✅ URL 단축기 상세 설계
**Base62 진법 변환 기법**을 기반으로 단축 URL을 생성


### 처리 흐름 
~~~
1. 긴 URL 입력
2. DB 조회
- 동일한 URL이 이미 저장되어 있다면?  
→ 기존 단축 URL 반환
3. 신규 URL이면
   - 전역적으로 유일한 ID 생성
     (DB 기본 키로 사용)
   - 생성된 ID를 Base62로 변환 → 단축 URL 생성
   - (ID, 단축URL, 원본URL) DB에 저장
4. 단축 URL 반환
~~~
 
## ✅ URL 리디렉션 상세 설계
URL 단축기는 **읽기(redirect)가 쓰기보다 훨씬 많은 시스템** -> 
따라서 성능 향상을 위해 **<단축 URL, 원본 URL> 매핑을 캐시에 저장**

 
### 처리 흐름
~~~
1. 사용자가 단축 URL을 클릭
2. 로드밸런서가 해당 요청을 웹 서버에 전달
3. 웹 서버는 캐시에서 단축 URL을 조회
   - 캐시에 있으면 → 원본 URL 반환
4. 캐시에 없다면 DB 조회
   - DB에도 없으면 → 404 Not Found(잘못된 url 입력)
5. DB에서 가져온 URL을 캐시에 저장한 뒤 사용자에게 반환

 ~~~

