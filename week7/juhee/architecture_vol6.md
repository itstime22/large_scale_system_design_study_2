# 13장 - 검색어 자동완성 시스템

## 1) 문제 정의와 범위

### 기능 범위
- 사용자가 입력하는 **검색어의 첫부분(prefix)** 기반 자동완성
- 항상 **5개** 추천 검색어 제공
- 추천은 **질의 빈도(frequency)** 기반 인기순
- **맞춤법 교정/자동 수정 제외**
- 입력 데이터는 **영어 소문자**로 가정
- 규모: **DAU 1천만**

### 비기능 요구사항
- 응답 속도: **100ms 이내**
- 연관성(prefix 기반)
- 정렬(인기순)
- 규모 확장성(트래픽/데이터 증가 대응)
- 고가용성

---

## 2) 규모 추정
- DAU: 10,000,000
- 사용자 1명당 일 10회 검색
- 평균 입력 크기: 20 bytes
- **검색창에서 글자 입력할 때마다** 자동완성 요청 발생  
  → “검색 1회”가 아니라 “타이핑 이벤트”가 QPS를 크게 키움

---

## 3) 개략 설계

### A. 데이터 수집 서비스 (write-heavy)
- 사용자 입력 질의를 실시간 수집
- 저장 구조 예:
  - `query`: 질의 문자열
  - `frequency`: 사용 빈도

**문제점**
- 데이터가 많아질수록 DB가 병목 가능
- prefix 기반 top-5 추출이 비효율

### B. 질의 서비스 (read-heavy)
- prefix를 입력받아 **상위 5개** 자동완성 결과를 반환
- 빠른 조회가 핵심

---

## 4) 상세 설계: Trie + Top-K 캐시

### Trie(트라이) 선택 이유
- 관계형 DB는 “prefix로 시작하는 문자열 중 top-k” 추출이 비효율적
- 문자열(prefix) 조회에 최적화된 자료구조가 Trie

### Trie 구조 요약
- 루트는 빈 문자열
- 각 노드는 글자 1개 저장, 자식은 최대 26개(영어 소문자)
- 노드는 단어 또는 접두어(prefix)를 표현

표기:
- `p`: 접두어 길이
- `n`: 트라이 노드 수
- `c`: 한 노드의 자식 수

### 기본 top-k 탐색 방식
1. prefix 노드 찾기
2. 하위 트리 탐색으로 유효 단어 노드 수집
3. 정렬 후 top-k 반환(대략 `O(c log c)`)

**한계**
- 최악의 경우 k개를 얻기 위해 트라이 전체 탐색에 가까워질 수 있음

### 해결책
#### (1) 접두어 최대 길이 제한
- prefix 길이를 제한하면 탐색 비용이 제한됨  
- `O(p)`를 사실상 `O(1)`로 취급 가능(상수 제한)

#### (2) 각 노드에 인기 검색어 top-k 캐시
- 각 노드에 “이 prefix의 top-k 인기 검색어”를 저장
- k는 작은 값(여기서는 5)

**효과**
- prefix 노드 찾기: `O(1)` 취급
- top-k 조회: `O(1)` 취급  
→ 100ms 요구사항을 만족시키는 핵심 트릭

**단점**
- 모든 노드에 top-k 저장 공간 필요(메모리 증가)
- 하지만 응답 속도 우선이면 충분히 감수할 만한 trade-off

---

## 5) 데이터 파이프라인(수집/취합/갱신)

### 문제 배경
- 매일 수천만 건 질의가 발생하는 환경에서
- 요청마다 Trie를 실시간 갱신하면 read path 성능이 하락

### 해결: 오프라인/비동기 갱신(배치)
구성 흐름:
1. **데이터 분석 서비스 로그**
   - 검색창 입력 질의 원본을 **append-only**로 저장
2. **로그 취합 서버**
   - 보통 **주 1회** 취합
3. **작업 서버(배치)**
   - 취합 데이터를 이용해 Trie 재생성
   - Trie DB에 저장
4. **Trie 캐시(분산 캐시)**
   - Trie 데이터를 메모리에 유지(읽기 고속)
   - **매주 스냅샷** 형태로 교체
5. **Trie DB(지속 저장소)**
   - 문서 저장소 또는 키-값 저장소 고려

---

## 6) 질의 서비스 흐름
1. 검색 질의 로드밸런서
2. LB → API 서버로 전달
3. API 서버 → Trie 캐시에서 prefix 조회 후 top-5 구성
4. 캐시에 없으면 Trie DB에서 읽고 캐시에 채움(cache fill)

---

## 7) 최적화와 확장

### 속도 최적화
- AJAX 요청(새로고침 없이 요청)
- 브라우저 캐싱(동일 prefix 재요청 감소)
- 데이터 샘플링(로깅/집계 비용 최적화)

### Trie 운영
- 생성: 작업 서버(배치)
- 갱신:
  - (선호) **주 1회 전체 교체**
  - (대안) 노드 단위 부분 갱신(트라이 작을 때만)
- 검색어 삭제:
  - Trie 캐시 앞단에 **필터 계층** 도입

### 저장소 확장(샤딩)
- 단순 “첫 글자 기준 샤딩”은 불균등 발생
- 해결: 과거 질의 패턴 분석 기반 샤딩 설계

### 확장 아이디어
- 비영어권: 유니코드 저장
- 국가별 순위: 국가별 Trie + CDN 배포
- 실시간 트렌드 반영:
  - 주 1회 갱신 방식은 부적합
  - 스트리밍 처리/랭킹 모델 고려 필요

---

# 14장 - 유튜브 설계

## 1) 문제 정의와 범위
- 빠른 비디오 업로드
- 원활한 비디오 재생
- 재생 품질 선택 기능
- 낮은 인프라 비용
- 높은 가용성과 규모 확장성, 안정성
- 지원 클라이언트: 모바일 앱, 웹 브라우저, 스마트 TV

---

## 2) 규모 추정
- DAU: 5,000,000
- 사용자 1명당 일 5개 동영상 시청
- 10% 사용자가 하루 1개 업로드
- 평균 동영상 크기: 300MB

### 저장소 증가량
- 하루 업로드 용량 = 5,000,000 × 10% × 300MB  
= 150TB/일

### CDN 비용(CloudFront $0.02/GB 가정)
- 하루 트래픽 = 5,000,000 × 5 × 0.3GB = 7,500,000GB
- 하루 비용 = 7,500,000 × 0.02 = $150,000/일  
→ CDN 비용이 크므로 최적화 필요

---

## 3) 개략 아키텍처

### 구성 요소
- 클라이언트(모바일/웹/TV)
- CDN: 사용자 근처 edge에서 스트리밍
- API 서버: 스트리밍 제외 기능 처리(로그인, 피드 추천, 업로드 URL 생성, 메타데이터 저장 등)

### 저장소/처리 계층
- 메타데이터 DB: URL, 사이즈, 포맷, 사용자 정보 등(샤딩/다중화)
- 메타데이터 캐시: 조회 성능 향상
- 원본 저장소(BLOB): 업로드된 원본 영상 저장
- 트랜스코딩 서버: 다중 포맷/해상도 변환
- 트랜스코딩 비디오 저장소(BLOB): 변환 결과 저장
- 트랜스코딩 완료 큐: 완료 이벤트 기록

---

## 4) 업로드/메타데이터 처리

### 업로드 흐름
1. 클라이언트가 원본 저장소에 업로드
2. 트랜스코딩 서버가 원본을 가져와 인코딩
3. 트랜스코딩 완료 시 병렬 처리:
   - 트랜스코딩 저장소 저장
   - 완료 이벤트 큐 기록
   - CDN 업로드
   - 완료 핸들러가 큐 이벤트 소비
   - 메타데이터 DB/캐시 갱신
4. API 서버가 업로드 완료 응답

### 메타데이터 갱신
- 업로드와 동시에 메타데이터 등록 요청
- API 서버가 캐시/DB 업데이트

---

## 5) 스트리밍
- 스트리밍은 CDN이 담당 → 지연 낮음
- 스트리밍 프로토콜마다 지원 인코딩/플레이어 상이
- 사용자에게 가장 가까운 CDN edge가 스트리밍 제공

---

## 6) 트랜스코딩 상세: DAG 파이프라인

### 트랜스코딩이 중요한 이유
- 저장 공간 절약
- 디바이스 호환성 확보
- 네트워크 대역폭 최적화(화질 선택/자동 전환)
- 모바일 환경에서 끊김 완화

### 기초 개념
- 컨테이너(.avi, .mov, .mp4)
- 코덱(압축/해제 알고리즘)

### DAG 모델 도입
- 작업을 단계로 나눠 병렬/순차 실행 가능하게 설계

작업 예:
- 품질 검사
- 다양한 해상도/코덱/비트레이트 인코딩
- 섬네일 생성
- 워터마크 삽입
- 비디오/오디오/메타데이터 분리 처리

### 파이프라인 구성
#### 전처리기
1) 비디오 분할(GOP 정렬 보조)  
2) 설정 파일 기반 DAG 생성  
3) 중간 데이터 캐시(실패 시 재시도 지원)

#### DAG 스케줄러
- DAG를 단계로 쪼개 자원관리자 작업 큐에 전달
- 1단계: 분리(비디오/오디오/메타데이터)
- 2단계: 인코딩/섬네일/오디오 인코딩

#### 자원관리자
- 작업 큐(우선순위)
- 작업 서버 큐(가용 서버)
- 실행 큐(진행 중 작업)
- 작업 스케줄러(작업-서버 매칭)

#### 임시 저장소
- 메타데이터: 메모리 캐시
- 비디오/오디오: BLOB 저장소
- 인코딩 완료 후 중간 데이터 삭제로 공간 확보

---

## 7) 최적화(속도/안정성/비용)

### 속도 최적화
- GOP 단위 분할 업로드로 병렬 업로드(실패 시 빠른 재개)
- 사용자 근처 업로드 센터 지정
- 메시지 큐로 단계 간 결합을 느슨하게 하여 병렬성 강화

### 안정성 최적화
- 미리 사인된 업로드 URL
- 비디오 보호: DRM / AES 암호화 / 워터마크

### 비용 최적화
- 인기 비디오는 CDN으로 제공
- 비인기 비디오는 서버를 통해 재생(트래픽 비용 절감)

---

## 8) 오류 처리
- 회복 가능 오류: 재시도 → 실패 지속 시 DLQ → 오류 코드 반환
- 회복 불가능 오류: 작업 중단 → 오류 코드 반환


