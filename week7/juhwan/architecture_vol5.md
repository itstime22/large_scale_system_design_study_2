# 🔍 검색어 자동 완성 시스템 설계

## 1️⃣ 문제 이해 및 설계 범위

### **핵심 요구사항**

- **빠른 응답 속도**: 100ms 이내
- **연관성**: 입력 단어와 연관된 추천 제공
- **정렬**: 인기도 등 순위 반영
- **확장성**: 대용량 트래픽 대응
- **고가용성**: 일부 장애 상황에서도 서비스 지속

### **규모 산정 예시**

- **DAU**: 천만 명
- **1인 평균 검색**: 10건/일
- **QPS(초당 질의 수)**:  
  약 24,000 (10,000,000×10/일/24/3600)
- **최대 QPS**: 약 48,000
- **신규 데이터**: 일 0.4GB (20% 발생시)

## 2️⃣ 아키텍처 초안

### **1. 데이터 수집 서비스**

- 실시간 사용 질의 로그 저장(추후 분석/갱신용)
- _대용량 서비스에서는 완전 실시간 DB 갱신 필요X, 로그 기반 배치가 좋음_

### **2. 질의 서비스**

- 주어진 접두사(프리픽스)로 인기검색어 5개 제공

### **3. 빈도 테이블**

- 질의/빈도 저장, 작은 규모에선 아래 쿼리로도 OK
  ```sql
  SELECT * FROM frequency_table WHERE query LIKE 'prefix%'
    ORDER BY frequency DESC
    LIMIT 5
  ```
- 데이터가 커지면 DB 부하↑ → 읽기 최적화 필요

---

## 3️⃣ 상세 설계

### **트라이(Trie) 자료구조**

- 문자열 검색에 특화된 트리 구조
- **기본 동작**
  1. 접두어 노드 탐색 `O(p)`
  2. 자식 노드(후보) 탐색 `O(c)`
  3. 빈도순 정렬(상위 K개) `O(c log c)`

#### **성능 최적화**

- **접두어 최대 길이 제한**: 접두어 탐색 빠르게 (`O(1)` 근사)
- **노드 인기 캐시**: 각 노드에 인기 K개 미리 보관 → 전체 트리 탐색 없이 `O(1)`

### **데이터 수집/갱신 흐름**

- 실시간 트라이 갱신은 부하↑
- **로깅→배치**: 원본 로그 저장, 주기적 작업서버가 트라이 재구성
- **트라이 DB/캐시**: 완성된 트라이 직접 저장(분산 캐시로 읽기 부하 최소화)
- **갱신 주기**: 일반적으로 매주 1회 전체 갱신

### **질의 처리 흐름**

1. 클라이언트 요청 → 로드밸런서
2. API서버 → 트라이캐시 조회
3. 캐시 미스 → DB 조회 후 캐시 갱신

---

#### **실무/최적화 추가 포인트**

- **AJAX 요청**: 페이지 리로드 없이 자동완성 제공
- **브라우저 캐싱**: 검색결과 max-age 등 헤더로 일부 캐싱
- **데이터 샘플링**: 모든 요청 로깅 X, 일부 샘플만 로그 (리소스 절감)
- **검색어 필터링**: 불건전(욕설, 혐오 등) 제외 계층 제공

#### **트라이 갱신 전략**

- _풀 리빌드(주로)_: 새 트라이 완성 후 교체
- 소규모 서비스는 “노드 갱신”도 고려 가능

#### **샤딩 전략**

- **1차:** 첫 글자 등 단순 분할
- **문제1:** 특정 글자 쏠림 발생
- **해결:** 인기 키/패턴·빈도 기반 샤딩 & 샤딩 매니저 도입

#### **다국어/국가별/실시간 트렌드**

- **다국어:** 유니코드 DB, separate trie per lang
- **국가별 인기:** CDN + per-country trie 캐시
- **실시간 HOT 검색:** 트렌딩 반영엔 스트림 프로세싱, 또는 샤드 수 늘려 병렬배치

# 📺 유튜브(대용량 영상 서비스) 시스템 설계

## 1️⃣ 기본 초점 및 규모 추정

### **설계 기본 목표**

- 빠른 비디오 업로드, 빠른 재생&다양한 품질
- 낮은 인프라 비용, 높은 가용·확장성
- 다양한 클라이언트(앱, 웹, TV) 지원

### **트래픽/저장소/비용 계산 예시**

- DAU: 5백만
- 사용자당 시청 5회/일, 업로드 10%
- 업로드 총량: 하루 150TB(300MB×50만건)
- **_CDN 비용 예시_**:  
  1GB당 $0.02, 하루 총 $150,000 (2025년 기준 가정치)

---

## 2️⃣ 전체 시스템 구조

### **핵심 구성요소**

- **단말**: 여러 기기 지원
- **CDN**: 동영상 스트리밍/캐싱
- **API 서버**: 메타정보·피드·업로드 관리
- **DB/캐시**: 메타데이터 저장/가속
- **원본저장소(BLOB)**: 원본 비디오 저장
- **트랜스코딩 서버**: 인코딩(품질/형식 변환)
- **작업큐/핸들러**: 메시지큐 통한 비동기 처리

### **업로드/트랜스코딩 병렬화**

- **프로세스 a:**
  1. 비디오 업로드 → 원본저장
  2. 트랜스코딩 서버가 인코딩 작업
  3. _병렬_:
     - 트랜스코딩본 저장&CDN 전송
     - 트랜스코딩 완료 이벤트 Q로 전송→DB/캐시 갱신
  4. API서버가 업로드완료/스트리밍준비 signal
- **프로세스 b:**
  - 업로드 중에도 메타데이터 갱신요청 가능 (병렬)

### **비디오 스트리밍**

- **스트리밍 방식:**
  - CDN이 Edge서버에서 바로 전달,  
    버퍼링 없이 빠른 재생
  - 전송은 단말/네트워크 상태/지역에 따라 변동

## 3️⃣ 상세 설계와 실전 포인트

### **트랜스코딩 체계**

- **저장 공간 절약**: 원본은 한 번, 재생본(화질/포맷별)은 여러개
- **단말 호환**: 기기별 Codec을 최대한 자동 인코딩/변환
- **사용자 경험/대역폭 대응**: 해상도·비트레이트별 인코딩, 네트워크 변화 반영
- **알고리즘: DAG로 작업 스케줄링**
  - 여러 인코딩/썸네일/워터마크 등의 작업을 DAG(비순환) 구조로 병렬처리

### **트랜스코딩 아키텍처**

- **전처리기:** 비디오 분할, DAG 생성, 임시 캐싱
- **DAG 스케줄러/자원관리:** 작업 분배·큐 스케줄 관리
- **작업서버:** 실제 인코딩, 썸네일 등
- **임시저장:** 중간 임시 데이터, 결과는 완성시 삭제

### **최적화 방법**

- **속도**: 업로드 병렬화, 지역별 업로드 센터(Edge), 모든 절차 async/mq 도입
- **안전**: presigned URL, DRM, 비밀번호·워터마크 등
- **비용최적화**: 인기 없는 비디오는 저가 스토리지/인코딩 생략, CDN 롱테일 활용

### **오류 처리**

- **회복 가능**: 일부 구간 실패 → 재시도
- **회복 불가**: 포맷오류 → 작업 중단 후 사용자 알림
- **컴포넌트별 내결함성 대책**: API 무상태, DB 다중화, 작업 재큐/사본 등 대응

## 4️⃣ 아키텍처 마무리 & 확장 사례

- **API는 stateless → 무한 수평확장**
- **DB/META 계층 다중화, 샤딩 이야기 나누기**
- **라이브(실시간) 스트리밍**: 더 짧은 지연, 스트리밍 프로토콜 설계 중요 (HLS, DASH 등)
- **비디오 삭제/관리 정책**: 신고, 저작권 침해 대응 등 자동화
- **지역별 CDN 전략, 가격/성능 Trade-off**
