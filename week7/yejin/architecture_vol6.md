# 📒 13장 - 검색어 자동완성 시스템



## ✅ 1단계 문제 이해 및 설계 범위 확정

1. 검색어의 첫부분
2. 총 5개의 자동 검색어
3. 질의 빈도에 따라 정해지는 검색어 인기 순위
4. 맞춤법, 자동 수정은 제외
5. 영어 소문자
6. DAU 기준 천만명

### 요구 사항
- 빠른 응답 속도 100밀리초 안
- 연관성
- 정렬
- 규모 확장성
- 고가용성

### 개략적 규모 추정
- dau:천만명
- 한 사용자는 매일 10건의 검색 수행
- 질의할때마다 평균적으로 20바이트의 데이터 입력
- 검색창에 글자를 입력할때마다 클라이언트는 백엔드에 검색어 자동완성 요청을 보냄


## ✅ 2단계 개략적 설계안 제시 및 동의 구하기 
1) 데이터 수집 서비스
- 사용자가 입력한 질의를 실시간으로 수집
- 질의 테이블

2) 질의 서비스
- 주어진 질의에 다섯 개의 인기 검색어를 정렬
- query: 질의문을 저장하는 필드
- frequency: 질의문이 사용된 빈도를 저장하는 필드
- 데이터가 많아지면 데이터베이스가 병목될 가능성 있음

## ✅ 3단계 상세 설계

### 트라이 자료 구조
- 관계형 db는 상위 5개를 뽑아내는데에 비효율
- 문자열을 꺼내는 연산에 초점을 맞추어 설계된 자료 구조
- 문자열을 간략하게 저장할 수 있는 자료구조
- 트리 구조
- 트리의 루트 노드는 빈 문자열 나타냄
- 각 노드는 글자 하나를 저장하며, 26개의 자식 노드를 가질 수 있음
- 각 트리 노드는 하나의 단어, 또는 접두어 문자열 나타냄
- p: 접두어 길이
- n: 트라이 안에 있는 노드 개수
- c: 주어진 노드의 자식 노드 개수

### 가장 많이 사용된 질의어 k개 찾는법
1. 해당 접두어 표현하는 노드 찾기
2. 해당 노드부터 하위 트리 탐색해 모든 유효 노드(유효한 검색 문자열 구성하는 노드) 찾기
3. 유효 노드를 정렬하여 가장 인기 있는 검색어 k 찾기(o(clongc))

### 문제
-  최악의 경우 k개 결과를 얻으려고 전체 트라이 다 검색하는 경우 생길 수 있음

### 해결
1. 접두어의 최대 길이 제한
- o(p)-> 0(1)

2. 각 노드에 인기 검색어 캐시
- k는 작은 값
- 단점: 각 노드에 질의어를 저장할 공간 필요
- 빠른 응답 속도가 필요한 경우는 저장공간 희생할만한 가치 있음
- 접두어 노드 찾는 시간 복잡도 o(1)로 변경
- 최고 인기 검색어 찾는 질의 시간 복잡도 o(1)로 변경


- 
### 데이터 수집 서비스

기존 문제점:
- 매일 수천만건 질의 응답될때 그때마다 트라이 갱신시 질의 서비스 속도 저하
- 트라이 갱신이 자주 필요하지 않음

- 데이터 분석 서비스 로그
    - 검색창에 입력된 질의에 관한 원본 데이터 보관( 오로지 추가만 )

- 로그 취합 서버
    - 대부분 일주일에 한번

- 취합된 데이터

- 작업 서버
    - 주기적으로 비동기적 작업을 실행하는 서버 집합
    - 트라이 자료 구조 만들고 트라이 데이터베이스에 저장하는 역할
- 트라이 캐시
    - 분산 캐시 시스템
    - 트라이 데이터를 메모리에 유지하여 읽기 연산 성능 높임
    - 매주 스냅샷
- 트라이 데이터베이스
    - 지속성 저장소

1. 문서 저장소
2. 키값 저장소


### 질의 서비스 

1. 검색 질의 로드밸런서
2. 로드밸러서는 질의를 api로 전송
3. api 서버는 트라이 케시에서 데이터를 가져와 자동완성 검색어 제안 응답 구성
4. 데이터가 트라이 캐시에 없는 경우 데이터를 데이터베이스에서 가져와 케시에 채움
->
### 속도 최적화 방안
- ajax 요청
: 새로고침 필요 없음
- 브라우저 캐싱
- 데이터 샘풀링


### 트라이 연산
1. 트라이 생성
- 작업 서버가 담당
- 데이터 분석 서비스의 로그나 데이터베이스로부터 취합된 데이터 이용

2. 트라이 갱신

2-1. 매주 한번 갱신, 기존 트라이 대체
2-2. 트라이 각 노드를 개별적 갱신
-> 성능이 좋지 않지만 트라이가 작을때 고려


3. 검색어 삭제
- 트라이 캐시 앞에 필터 계층

### 저장소 규모 확장

1. 샤딩
-> a로 시작하는 것 4개로 나눔
->c로 시작하는데 x보다 많음
-> 불균등

해결:
- 과거 질의 데이터 패턴 분석하여 샤딩

## ✅ 4단계 마무리
- 비영어권: 트라이에 유니코드 데이터 저장
- 국가별로 순위 다를 경우: 국가벼로 트라이 사용, 트라이를 cdn에 저장하여 응답속도 높이는 방법 생각
- 실사간 변하는 검색어 추이 반영: 
    - 지금 설계는 적합하지 않음
    - 지금은 일주일에 한번 갱신으로 인해

+ 샤딩
+ 순위 모델
+ 데이터가 스크림 형태로 올 수도 있음-> 한번에 모든 데이터 처리 불가능

