# 📒 13장 - 검색어 자동완성 시스템



## ✅ 1단계 문제 이해 및 설계 범위 확정

1. 검색어의 첫부분
2. 총 5개의 자동 검색어
3. 질의 빈도에 따라 정해지는 검색어 인기 순위
4. 맞춤법, 자동 수정은 제외
5. 영어 소문자
6. DAU 기준 천만명

### 요구 사항
- 빠른 응답 속도 100밀리초 안
- 연관성
- 정렬
- 규모 확장성
- 고가용성

### 개략적 규모 추정
- dau:천만명
- 한 사용자는 매일 10건의 검색 수행
- 질의할때마다 평균적으로 20바이트의 데이터 입력
- 검색창에 글자를 입력할때마다 클라이언트는 백엔드에 검색어 자동완성 요청을 보냄


## ✅ 2단계 개략적 설계안 제시 및 동의 구하기 
1) 데이터 수집 서비스
- 사용자가 입력한 질의를 실시간으로 수집
- 질의 테이블

2) 질의 서비스
- 주어진 질의에 다섯 개의 인기 검색어를 정렬
- query: 질의문을 저장하는 필드
- frequency: 질의문이 사용된 빈도를 저장하는 필드
- 데이터가 많아지면 데이터베이스가 병목될 가능성 있음

## ✅ 3단계 상세 설계

### 트라이 자료 구조
- 관계형 db는 상위 5개를 뽑아내는데에 비효율
- 문자열을 꺼내는 연산에 초점을 맞추어 설계된 자료 구조
- 문자열을 간략하게 저장할 수 있는 자료구조
- 트리 구조
- 트리의 루트 노드는 빈 문자열 나타냄
- 각 노드는 글자 하나를 저장하며, 26개의 자식 노드를 가질 수 있음
- 각 트리 노드는 하나의 단어, 또는 접두어 문자열 나타냄
- p: 접두어 길이
- n: 트라이 안에 있는 노드 개수
- c: 주어진 노드의 자식 노드 개수

### 가장 많이 사용된 질의어 k개 찾는법
1. 해당 접두어 표현하는 노드 찾기
2. 해당 노드부터 하위 트리 탐색해 모든 유효 노드(유효한 검색 문자열 구성하는 노드) 찾기
3. 유효 노드를 정렬하여 가장 인기 있는 검색어 k 찾기(o(clongc))

### 문제
-  최악의 경우 k개 결과를 얻으려고 전체 트라이 다 검색하는 경우 생길 수 있음

### 해결
1. 접두어의 최대 길이 제한
- o(p)-> 0(1)

2. 각 노드에 인기 검색어 캐시
- k는 작은 값
- 단점: 각 노드에 질의어를 저장할 공간 필요
- 빠른 응답 속도가 필요한 경우는 저장공간 희생할만한 가치 있음
- 접두어 노드 찾는 시간 복잡도 o(1)로 변경
- 최고 인기 검색어 찾는 질의 시간 복잡도 o(1)로 변경


- 
### 데이터 수집 서비스

기존 문제점:
- 매일 수천만건 질의 응답될때 그때마다 트라이 갱신시 질의 서비스 속도 저하
- 트라이 갱신이 자주 필요하지 않음

- 데이터 분석 서비스 로그
    - 검색창에 입력된 질의에 관한 원본 데이터 보관( 오로지 추가만 )

- 로그 취합 서버
    - 대부분 일주일에 한번

- 취합된 데이터

- 작업 서버
    - 주기적으로 비동기적 작업을 실행하는 서버 집합
    - 트라이 자료 구조 만들고 트라이 데이터베이스에 저장하는 역할
- 트라이 캐시
    - 분산 캐시 시스템
    - 트라이 데이터를 메모리에 유지하여 읽기 연산 성능 높임
    - 매주 스냅샷
- 트라이 데이터베이스
    - 지속성 저장소

1. 문서 저장소
2. 키값 저장소


### 질의 서비스 

1. 검색 질의 로드밸런서
2. 로드밸러서는 질의를 api로 전송
3. api 서버는 트라이 케시에서 데이터를 가져와 자동완성 검색어 제안 응답 구성
4. 데이터가 트라이 캐시에 없는 경우 데이터를 데이터베이스에서 가져와 케시에 채움
->
### 속도 최적화 방안
- ajax 요청
: 새로고침 필요 없음
- 브라우저 캐싱
- 데이터 샘풀링


### 트라이 연산
1. 트라이 생성
- 작업 서버가 담당
- 데이터 분석 서비스의 로그나 데이터베이스로부터 취합된 데이터 이용

2. 트라이 갱신

2-1. 매주 한번 갱신, 기존 트라이 대체
2-2. 트라이 각 노드를 개별적 갱신
-> 성능이 좋지 않지만 트라이가 작을때 고려


3. 검색어 삭제
- 트라이 캐시 앞에 필터 계층

### 저장소 규모 확장

1. 샤딩
-> a로 시작하는 것 4개로 나눔
->c로 시작하는데 x보다 많음
-> 불균등

해결:
- 과거 질의 데이터 패턴 분석하여 샤딩

## ✅ 4단계 마무리
- 비영어권: 트라이에 유니코드 데이터 저장
- 국가별로 순위 다를 경우: 국가벼로 트라이 사용, 트라이를 cdn에 저장하여 응답속도 높이는 방법 생각
- 실사간 변하는 검색어 추이 반영: 
    - 지금 설계는 적합하지 않음
    - 지금은 일주일에 한번 갱신으로 인해

+ 샤딩
+ 순위 모델
+ 데이터가 스크림 형태로 올 수도 있음-> 한번에 모든 데이터 처리 불가능


# 📒 14장 - 유튜브 설계


## ✅ 1단계 문제 이해 및 설계 범위 확정
~~~
- 빠른 비디오 업로드
- 원활한 비디오 재생
- 재생 품질 선택 기능
- 낮은 인프라 비용
- 높은 가용성과 규모 확장성, 안정성
- 지원 클라이언트: 모바일 앱, 웹브라우저, 스마트 tv
~~~



### 대략적 규모 추정
- 5백만 DAU
- 사용자 1명이 하루 평균 5개 동영상 시청
- 10%의 사용자가 하루 1개 동영상 업로드
- 평균 동영상 크기 300MB
- 하루 저장공간 필요량: 5백만 * 10% * 300MB = 150TB
- CDN 비용 (Amazon CloudFront 기준, $0.02/GB):
    -   하루 트래픽: 5백만 * 5개 * 0.3GB = 7,500,000GB
    - 하루 비용: 7,500,000 * $0.02 = $150,000
- CDN 비용이 막대하므로 비용 최적화 방안 필요

## ✅ 2단계 개략적 설계안 제시 및 동의 구하기

- 단말(클라이언트): 컴퓨터, 스마트폰, 스마트TV 등 다양한 디바이스
- CDN: 비디오 재생 요청 시 가까운 CDN 서버에서 데이터 제공
- API 서버: 로그인, 피드 추천, 업로드 URL 생성, 메타데이터 저장/갱신 등 비디오 스트리밍을 제외한 모든 요청 처리

### 비디오 업로드 절차

### 컴포넌트

- 사용자: 컴퓨터, 모바일 폰, 스마트TV 등을 통해 유튜브를 시청하는 이용자

- 로드밸런서: API 서버로 요청 분산

- API 서버: 비디오 스트리밍을 제외한 모든 요청을 처리

- 메타데이터 DB:
비디오의 메타데이터(URL, 사이즈, 포맷, 사용자 정보 등)를 저장
샤딩, 다중화 등을 통해 고가용성 확보

- 메타데이터 캐시: 성능 향상을 위해 메타데이터를 캐싱

- 원본 저장소: 업로드된 원본 비디오를 저장하는 대형 이진 파일 저장소(BLOB)

- 트랜스코딩 서버: 다양한 디바이스와 네트워크 환경에 맞게 영상 포맷 변환

- 트랜스코딩 비디오 저장소: 트랜스코딩된 영상을 저장하는 BLOB 저장소

- CDN (콘텐츠 전송 네트워크): 사용자 근처에서 영상을 빠르게 스트리밍

- 트랜스코딩 완료 큐: 트랜스코딩 완료 이벤트를 기록하는 큐

### a.비디오 업로드 

1. 클라이언트가 비디오 파일을 원본 저장소에 업로드

2. 트랜스코딩 서버가 원본 영상을 가져와 다양한 포맷으로 인코딩

3. 트랜스코딩 완료 시 병렬적으로:
   - 변환된 영상을 트랜스코딩 비디오 저장소에 저장
   - 트랜스코딩 완료 큐에 이벤트 기록
   - 트랜스코딩이 끝난 비디오를 CDN에 업로드
   - 완료 핸들러가 이벤트 데이터를 큐에서 꺼냄
   - 완료 핸들러가 메타데이터 DB와 캐시를 갱신

4. API 서버가 클라이언트에게 업로드 완료 응답

### b.메타데이터 갱신
- 비디오 파일 업로드와 동시에 메타데이터 갱신 요청을 API 서버에 보냄
- 메타데이터 등록 요청은 파일 이름, 사이즈, 포맷 등 정보를 포함
- API 서버는 메타데이터 캐시, DB를 업데이트


### 비디오 스트리밍 절차
- 스트리밍 프로토콜마다 지원하는 비디오 인코딩과 플레이어가 다름
- 비디오는 CDN에서 바로 스트리밍되므로 전송 지연이 낮음 -> 사용자의 단말에 가장 가까운 CDN 에지 서버가 담당

## ✅ 3단계 상세 설계
### 비디오 트랜스코딩
비디오 트랜스코딩이 중요한 이유:
- 대용량 저장 공간 절약: 원본 고화질 비디오는 매우 큰 저장공간을 차지
- 다양한 디바이스 호환성: 다양한 기기/브라우저는 특정 포맷만 지원
- 네트워크 대역폭 최적화: 사용자의 네트워크 속도에 따라 고화질 또는 저화질 버전을 스트리밍
- 모바일 환경 대응: 네트워크 상태가 불안정할 때 원활한 비디오 재생을 위해 화질 자동 전환 필요

구성 요소:
- 컨테이너: 비디오, 오디오, 메타데이터를 묶는 포맷 (.avi, .mov, .mp4 등)
- 코덱: 압축, 압축 해제 알고리즘

### 유향 비순환 그래프(DAG)모델
문제: 트랜스코딩은 연산량이 많고 복잡하므로 유연성과 병렬성이 필요
해결책: 작업(Task)을 여러 단계로 나누어 순차/병렬로 실행 가능한 DAG 모델 도입

- 원본 데이터는 비디오, 오디오, 메타데이터로 나누어서 처리됨
- 비디오 부분에 적용되는 작업:
    - 검사: 비디오 품질 검사
    - 비디오 인코딩: 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩
    - 섬네일: 사용자가 업로드한 이미지나 비디오에서 자동 추출된 이미지로 섬네일 생성
    - 워터마크: 비디오에 대한 식별정보를 이미지 위에 오버레이로 띄움


### 비디오 트랜스코딩 아키텍처
클라우드 서비스를 활용하여 비디오 트랜스코딩 파이프라인 구성

전처리기
1. 비디오 분할
    - 일부 오래된 모바일 기기나 브라우저는 비디오를 GOP(Group of Pictures)에 맞춰 나누는 기능을 지원하지 않음
    - 이 경우, 전처리기가 GOP 정렬에 맞춰 비디오를 분할함

2. DAG 생성
    - 전처리기는 클라이언트 프로그래머들이 작성한 설정 파일을 바탕으로 DAG 구조를 생성
    - DAG는 어떤 작업이 어떤 작업 다음에 실행되어야 하는지를 정의

3. 데이터 캐시
    - 전처리기는 분할된 비디오 데이터(GOP)와 메타데이터를 임시 저장소에 저장
    - 이 임시 저장소는 비디오 인코딩 실패 시 이 데이터를 다시 활용하여 재시도



### DAG 스케줄러
DAG 스케줄러: DAG 그래프를 몇 개 단계로 분할 후, 각각을 자원 관리자의 작업 큐에 집어 넣음
1. 첫 번째 단계: 비디오, 오디오, 메타데이터 분리
2. 두 번째 단계: 해당 비디오 파일을 인코딩하고 섬네일 추출하고 오디오 파일 인코딩
### 자원관리자
자원 배분을 효과적으로 수행하는 역할 담당

구성 요소:

- 작업 큐: 수행해야 할 작업들을 저장하는 우선순위 큐
- 작업 서버 큐: 사용 가능한 작업 서버의 정보를 저장하는 우선순위 큐
- 실행 큐: 현재 실행 중인 작업과 해당 작업을 수행 중인 작업 서버 정보를 저장하는 큐
- 작업 스케줄러: 최적의 작업/서버 조합을 골라, 해당 작업 서버가 작업을 수행하도록 지시

작업 관리자 동작:

- 작업 큐에서 가장 높은 우선순위의 작업을 꺼냄
- 작업 서버 큐에서 가장 적합한 작업자를 선택
- 선택한 작업자에게 작업을 할당
- 해당 작업이 어떤 서버에 할당되었는지에 관한 정보를 실행 큐에 넣음
- 작업이 완료되면 실행 큐에서 해당 작업 정보를 제거

### 임시 저장소
- 임시 저장소는 비디오 처리 중간 데이터를 보관
- 데이터 유형에 따라 다른 저장소 사용:
    - 메타데이터는 메모리 캐시
    - 비디오 및 오디오 데이터는 BLOB 저장소
- 비디오 인코딩 완료 후, 해당 데이터는 삭제하여 저장소 공간 확보
### 인코딩된 비디오
- 최종 결과물


### 시스템 최적화
- 속도 최적화: 비디오 병렬 업로드
    - 하나의 비디오를 작은 GOP로 분할하여 병렬적으로 업로드
    - 일부가 실패해도 빠르게 업로드를 재개

- 속도 최적화: 업로드 센터를 사용자 근거리에 지정

- 속도 최적화: 모든 절차를 병렬화
    - 각 작업 사이에 메시지 큐를 도입해서 느슨하게 결합된 시스템을 만들어 병렬성을 높임


- 안정성 최적화: 미리 사인된 업로드 URL
- 안정성 최적화: 비디오 보호
    - DRM
    - AES 암호화
    - 워터마크

- 비용 최적화
    - CDN 비용 최적화를 하기 위해 인기 비디오는 CDN을 통해 재생시키고, 다른 비디오는 서버를 통해 재생

### 오류 처리
1. 화복 가능 오류
    - 회복 가능한 오류면 몇 번 재시도하고, 계속 실패한다면 DLQ(Dead Letter Queue)에 넣고 클라이언트에게 적절한 오류 코드를 반환

2. 회복 불가능 오류:
    -  회복이 불가능한 오류는 해당 작업을 중단하고 클라이언트에게 적절한 오류 코드를 반환

## ✅ 4단계 마무리

- API 계층의 규모 확장성 확보 방안
- 데이터베이스 계층의 규모 확정성 확보 방안
- 라이브 스트리밍
- 비디오 삭제